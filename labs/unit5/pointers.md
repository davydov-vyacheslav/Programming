# Вступ до показчиків

<!-- apline package: apk add vim clang llvm clang-extra-tools cppcheck gtest compiler-rt gtest-dev -->
<!-- and more: compiler-rt-static check-dev check lldb valgrind -->

## Структура директорії для лабораторної роботи

```
└── lab11
    ├── Doxyfile
    ├── Makefile
    ├── README.md
    ├── doc
    │   └── lab11.md
    ├── test
    │   └── test.c
    └── src
        ├── lib.c
        ├── lib.h
        └── main.c
```

**Зверніть увагу!**. При роботі з пам'яттю можуть виникати витоки пам'яті. Для дослідження цих витоків слід використовувати утиліту *valgrind*, додав та використовував (`make leak-check`) наступну ціль:
```sh
V_FLAGS=--tool=memcheck --leak-check=full --show-reachable=yes \
	--undef-value-errors=yes --track-origins=no --child-silent-after-fork=no \
	--trace-children=no --error-exitcode=1

leak-check: clean prep compile
	valgrind $(V_FLAGS) --log-file=dist/valgrind.log --xml-file=dist/valgrind.xml --xml=yes dist/main.bin
	valgrind $(V_FLAGS) --log-file=dist/valgrind.log --xml-file=dist/valgrind.xml --xml=yes dist/test.bin
```

**Альтернативний варіант** за використанням `llvm`:
    - при компіляції (C_OPTS) додати опцію `-fsanitize=address`
    - створити `leak-check` ціль наступним чином:

```sh
leak-check: clean prep compile
    ASAN_OPTIONS=detect_leaks=1 dist/main.bin
    ASAN_OPTIONS=detect_leaks=1 LLVM_PROFILE_FILE="dist/test.profraw" dist/test.bin
```

## Індивідуальні завдання.

Виконати одне завдання з пулу завдань на свій розсуд згідно її складності (що впливає на максимальну оцінку, що може бути отримана за лабораторну роботу). 

**Зверніть увагу**. Викладач має право надати вам додаткове завдання для виконання.

**Зверніть увагу**. При виконанні завдання ви повинні використовувати динамічне виділення пам'яті для масивів.

1.	Дано масив з *N* цілих чисел. Знайти мінімальний та максимальний елементи масиву. Визначити суму елементів, що розташовані між цими елементами. Створити другий масив, що містить ці елементи.
2.	Дано два масиви: *mas1[N]* і *mas2[M]*. Створити третій масив, у який переписати елементи масиву *mas1*, а потім *mas2*. Отриманий масив упорядкувати за зростанням.
3.	Дано два масиви: *mas1[N]* і *mas2[M]*. Створити третій масив, у який переписати по черзі по два елементи з вхідних масивів; почати з масиву *mas2*. 
4.	Дано масив з *N* речовинних чисел. Розмістити всі елементи з позитивними значеннями в лівій частині масиву, елементи з негативними значеннями – у правій, а нулі – між ними.
5.	Дано масив з *N* цілих позитивних чисел. Визначити, які числа в масиві є довершеними (такими, що дорівнюють сумі своїх дільників), та перенести їх до нового масиву.
6.	Дано масив з *N* речовинних чисел. Створити другий масив, який буде мати у собі усі елементи початкового масиву, що розташовані між першим та другим негативними елементами. 
7.	(`*`) Дано масив з *N* цілих чисел. Визначити кількість пар сусідніх елементів з однаковими значеннями. Ці пари переписати у другий масив. Зверніть увагу: 3 послідовних числа - це одна пара та один елемент "без пари".
8. 	(`*`) Дано масив масивів з *N* * *N* цілих чисел. У кожному рядку масиву знайти кількість парних додатних чисел. Отримані результати записати в одновимірний масив.
9. 	(`*`) Даний масив масивів з *N* * *N* речовинних чисел. Максимальні елементи кожного стовпця переписати в одновимірний масив.
10.	(`*`) Дано масив масивів з *N* * *N* цілих чисел. Елементи головної діагоналі записати в одновимірний масив, отриманий масив упорядкувати за зростанням.
11.	(`**`) Дано масив з *N* цілих чисел. Визначити, чи є в масиві елементи, що повторюються; якщо такі є, то створити масив, в якому вказати, скільки разів які елементи повторюються. Таким чином, в результуючому масиві кожен непарний елемент - число, що повторюються; кожен парний елемент - кількість повторювань.
12.	(`**`) Дано масив з *N* цілих чисел. Знайти безперервну послідовність позитивних чисел у вхідному масиві, сума елементів якої максимальна, та переписати їх у вихідний масив.
13.	(`**`) Дано масив з *N* речовинних чисел. Підрахувати кількість ділянок, які утворюють безперервні послідовності чисел з не-зменшуваними значеннями. Максимальну ділянку переписати у інший масив.
14.	(`**`) Дано масив масивів з *N* * *N* цілих чисел. Елементи головної  діагоналі записати в одновимірний масив, отриманий масив упорядкувати за зростанням.


## Додаткові обов'язкові умови виконання робот

- програма має мати документацію, що оформлена за допомогою утиліти doxygen;
- звіт повинен бути оформлений згідно "Вимогам до структурної побудови звіту";
- продемонструвати відсутність витоків пам’яті;
- доступ до елементів масиву здійснювати через розіменування покажчиків, а не через оператор індексування (*[ ]*);
- продемонструвати роботу розроблених методів за допомогою модульних тестів;
- у звіті навести ступень покриття коду модульними тестами. 50% - є мінімально допустимим відсотком покриття коду тестами.
- (як і раніше) забороняється використовувати функції введення/виведення. Вхідні дані повинні бути у вигляді констант, вихідні дані повинні бути відображені за допомогою відлагодника.


## Контрольні питання.
1.	Як створити покажчик на масив?
2.	Які операції можуть бути застосовані до покажчиків?
3.	Як здійснюється звільнення пам’яті?
4.	Як здійснюється виділення пам’яті?
5.	Як створюється контроль за витоком пам’яті?
6.	Чим відрізняється статичний масив від динамічного?
7.	Як визначити поточний обсяг пам’яті для динамічного масиву?
8.	Що виконується в наступному фрагменті програмного коду?
```c
pointMas = &mas[0];  
for(i = 0; i < arraySize; *pointMas++ = i++);  
```		
9.	Чому треба звільняти пам’ять, яка динамічно виділялась?

