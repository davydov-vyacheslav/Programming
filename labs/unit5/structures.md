# Структуровані типи даних
## Загальне завдання

- з розділу [Індивідуальні завдання комплексної роботи](../common/complex-tasks.md) взяти прикладну галузь стосовно номеру варіанту за попередньо-визначеною формулою
- створити структуру, що відображає "базовий клас"

## Структура директорії для лабораторної роботи

```
└── lab15
    ├── Doxyfile
    ├── Makefile
    ├── README.md
    ├── assets
    │   └── input.txt
    ├── doc
    │   └── lab15.md
    ├── test
    │   └── test.c
    └── src
        ├── lib.c
        ├── lib.h
        └── main.c
```

**Зверніть увагу**. Вхідні дані розташовані у файлі `assets/input.txt`. Програма повинна прийняти у якості аргументу шлях до цього файлу (як і у попередній роботі). 

**Зверніть увагу**. Очікується, що при запуску програми з параметрами командної строки, нічого від користувача не буде очікуватись.

**Зверніть увагу**. Передача об'єктів структури в функцію (та отримання результатів роботи функції, що є об'єкт типу структури) обов'язково повинні передаватися "за вказівником".


## Індивідуальні завдання.

### Обов'язкові завдання

- розробити функцію, яка читає дані (масив елементів) з файлу;
- розробити функцію, яка записує дані (масив елементів) у файл;
- розробити функцію, яка виводить масив елементів на екран;
- реалізувати функцію №1 з категорії "Методи для роботи з колекцією", на вхід якої потрапляє масив об'єктів. Слід звернути увагу, що усі необхідні дані повинні бути передані як аргументи функції. Наприклад, якщо треба знайти всі машини марки "Форд", то функція потрібна мати аргумент "марка машини", та у main() викликати цю функцію з потрібним значенням марки.
- розробити функцію, яка буде сортувати масив елементів за заданим критерієм (полем);

### Додаткові завдання на розсуд викладача

1. Розробити функцію, яка генерує елемент прикладної галузі згідно з індивідуальним завданням, при цьому:
   - чисельні поля генеруються за допомогою функції *rand()* у діапазоні $[N..N*10]$, де *N* – номер варіанту;
   - рядкові поля подані у вигляді конкатенації двох рядків:, напр., "Студент №" та унікального числа. 
2. Виконати запис та читання масиву структур (з заздалегідь відомою кількістю елементів) у двох форматів: текстовому та бінарному. При бінарному методі зберігання структур виконати пошук та читання структури з файлу по індексу (за допомогою використання функції *fseek*).

## Додаткові обов'язкові умови виконання робот

- програма має мати документацію, що оформлена за допомогою утиліти doxygen;
- звіт повинен бути оформлений згідно "Вимогам до структурної побудови звіту";
- продемонструвати відсутність витоків пам’яті;
- доступ до елементів масиву здійснювати через розіменування покажчиків, а не через оператор індексування (*[ ]*);
- продемонструвати роботу розроблених методів за допомогою модульних тестів;
- у звіті навести ступень покриття коду модульними тестами. 50% - є мінімально допустимим відсотком покриття коду тестами.

## Контрольні питання.
1.	Як виконати доступ до окремих елементів структури?
2.	Чи можна вміст однієї структури привласнити іншій того ж типу, використовуючи звичайний оператор присвоювання?
3.	Коли необхідно використовувати покажчики на структури?
4.	Чи може бути членом структури інша структура?
5.	Чим відрізняється об’єднання від структури?
6.	Чим відрізняються бітові поля від звичайних структур?
7.	Що являє собою перерахування?
8.	Що являє собою суміш?
