# Вступ до ООП

## Prerequisites

* Створити *новий* репозиторій (по аналогії з інснуючим) з назвою: *programing-FNAME-cpp* (`programing-davydov-cpp`): 
* Додати до репозиторію файли:
	- `.clang-format` з директорії `lab-cpp00` репозиторію `sample_project`
	- `.clang-tidy` з директорії `lab-cpp00` репозиторію `sample_project`
* модульні тести потрібно (пере)робити за допомогою Google Test Framework: https://google.github.io/googletest/, при цьому, рекомендовано проінсталювати `googletest` пакет та використовувати наступні опції при компіляції тестів `-lgtest -lgtest_main`. Приклад переробленого тесту наведено у `lab-cpp00` проекту `sample_project` репозиторію.

<!--	- `.gitlab-ci.yml` з наступним контентом:
```
include: https://gitlab.com/davs/cicd-pro-checker/-/raw/master/subjects/pro2/.gitlab-ci.yml
``` -->

## Структура директорії для лабораторної роботи

```
└── lab-cpp-01
    ├── Doxyfile
    ├── Makefile
    ├── README.md
    ├── doc
    │   └── lab-cpp-01.md
    ├── test
    │   └── test.cpp
    └── src
        ├── entity.cpp
        ├── entity.h
        ├── list.cpp
        ├── list.h
        └── main.cpp
```


## Загальне завдання. 

Для предметної галузі з розділу [Розрахункове завдання / Iндивідуальні завдання](../common/complex-tasks.md) розробити два класи:

- клас, що відображає сутність "базового класу", у тому числі: 
	- конструктор за замовчуванням, копіювання та конструктор з аргументами (реалізація конструкторів повинна бути продемонстрована за допомогою списків ініціалізацій); 
	- деструктор;
	- гетери та сетери на поля класу;
	- метод виводу об'єкта на екран:
```cpp
void Phone::print();
```
- клас, що має у собі динамічний масив об’єктів базового класу та має в собі методи додавання, видалення елемента, отримання елемента по індексу (або ідентифікатору), вивід усіх елементів на екран. Рекомендовані сигнатури методів:
   - додавання: 
```cpp
void List::addPhone(const Phone& phone, size_t pos = 0);
```
   - видалення: 
```cpp
void List::removePhone(size_t index);
```
   - отримання по індексу: 
```cpp
Phone& List::getPhone(size_t index);
```
   - виведення усіх елементів:
```cpp
void List::print(); 
```
   - метод 1 обходу колекції. Приклад сигнатури такого методу (У наведеному прикладі реалізоване завдання пошуку самого дешевого телефону з заданою діагоналлю (повертається один телефон):
```cpp
const Phone& List::findCheapestPhone(unsigned float diagonal);
```

<!-- TODO: precise tests -->

## Обов'язково забезпечити!!!

- усі поля "базового класу" повинні бути приватними та мати публічні гетери та сетери (модифікатори доступу), використовувати механізм інкапсуляції;
- усі функції, що не повинні змінювати поля поточного об’єкта, повинні бути константними;
- усі аргументи функцій, що не змінюються, по можливості також повинні бути константними. Якщо їх не можна зробити константними, у такому разі повинно бути обґрунтування цього;
- у класі-списку метод додавання елемента не повинен вводити дані з клавіатури або файлу, а повинен приймати вже готовий об’єкт для додавання. Метод вводу даних має бути відокремленим;
- продемонструвати відсутність витоків пам’яті;
- продемонструвати роботу розроблених методів класу-списку за  допомогою модульних тестів.
- конструктори та деструктори повинні мати логіруючі повідомлення. 

Студент повинен продемонструвати виклик деструктора та кожного типу конструктора, а також пояснити, коли вони викликаються;


## Контрольні запитання
1. Що таке клас? Чим він відрізняється від структури?
2. Що таке метод? Чим він відрізняється від функції?
3. Що таке інкапсуляція?
4. Що таке константні методи? Наведіть приклади.
5. Як визначити розмір об’єкта у пам’яті?
6. Для чого потрібні права доступу?
7. Які методи потрібні для доступу до private-атрибутів?
8. Для чого потрібні const-методи?
9. Коли є смисл у константних методах?
10. Чи може бути атрибут константним?
11. Для чого потрібні конструктори?
12. Які ви знаєте відмінності конструкторів?
13. Чи можна перевантажувати конструктори?
14. Для чого потрібні деструктори?
15. Які відмінності деструктора?
16. Що таке конструктор копіювання? Для чого він потрібен?
17. Коли викликаються конструктори та деструктор?
18. Що таке списки ініціалізації?
19. Що таке перевантаження методів?
20. Чим визначається виклик перевантажених методів?

