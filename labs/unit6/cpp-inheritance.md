# Спадкування. Поліморфізм
## Структура директорії для лабораторної роботи

```
└── lab-cpp-04
    ├── Doxyfile
    ├── Makefile
    ├── README.md
    ├── doc
    │   ├── lab-cpp-04.md
    │   └── assets
    │       └── uml.png
    ├── test
    │   └── test.cpp
    └── src
        ├── entity.cpp
        ├── entity.h
        ├── list.cpp
        ├── list.h
        └── main.cpp
```

## Загальне завдання
Модернізувати попередню лабораторну роботу (оператори) наступним чином:

- базовий клас зробити абстрактним. Додати абстрактні методи;
- додати класи-спадкоємці з розділу [Розрахункове завдання / Iндивідуальні завдання](../common/complex-tasks.md), котрі будуть поширювати функціонал "базового класу" відповідно до індивідуального завдання;
- повинно бути реалізовано усі 3 методи з розділу [Розрахункове завдання / Iндивідуальні завдання](../common/complex-tasks.md);
- клас-список переробити таким чином, щоб він міг працювати як з базовим класом, так і з його спадкоємцями. При цьому серед полів класу-списку повинен бути лише один масив, що містить усі типи класів ієрархії. Оновити методи, що працюють з цим масивом.
- у функціях базового класу та класів-спадкоємців обов’язкове використання ключових слів `final` та `override`.
- упевнитися, що оператори вводу/виводу працюють коректно для усіх класів їєрархії.
- у звіти необхідно навести UML діаграму ієрархії класів

<!-- TODO: implement operators in children-->

## Додаткові обов'язкові умови виконання робот.

- програма має мати документацію, що оформлена за допомогою утиліти doxygen;
- робота повинна бути оформлена згідно "Вимогам до структурної побудови звіту";
- продемонструвати відсутність витоків пам’яті за допомогою утиліти *valgrind*;
- продемонструвати роботу розроблених методів за допомогою модульних тестів;
- у звіті навести ступень покриття коду модульними тестами. 50% - є мінімально допустимим відсотком покриття коду тестами;
- продемонструвати роботу розроблених методів за допомогою модульних тестів;
- не використовувати конструкцію "using namespace std;", замість цього слід робити "using" кожного необхідного класу, наприклад: using std::string,  using std::cout;
- у проекті не повинні використовуватися бібліотеки введення / виведення мови C, а також не повинні використовуватися рядки типу `char*`.

<!-- TODO: precise tests -->

## Контрольні запитання

1. Для чого потрібне спадкування?
2. Як впливають права доступу атрибутів на спадкування?
3. Які бувають атрибути при спадкуванні і на що вони впливають?
4. Коли працює спадкування для об’єктів-нащадків?
5. Що таке "ієрархія" класів?
6. Які ієрархії у спадкуванні можуть бути? Наведіть приклади.
7. Чим відрізняється спадкування від агрегації?
8. Що таке поліморфізм?
9. Для чого потрібні віртуальні методи?
10. Які методи називають "чисто віртуальними"?
11. Що таке таблиця віртуальних методів?
12. Що таке абстрактний клас?
13. Чи можна створити об’єкт абстрактного класу?
14. Що таке інтерфейс?
15. Які умови необхідно виконати для реалізації поліморфізму?
16. Чим відрізняється абстрактний клас від інтерфейсу?
17. Чим відрізняється абстрактний клас від звичайного класу?
18. Яких правил треба дотримуватись при перевизначенні віртуальних методів?
19. Яке призначення ключових слів final та override?
