# Потоки

## Структура директорії для лабораторної роботи

```
└── lab-cpp-02
    ├── Doxyfile
    ├── Makefile
    ├── README.md
    ├── doc
    │   └── lab-cpp-02.md
    ├── test
    │   └── test.cpp
    └── src
        ├── entity.cpp
        ├── entity.h
        ├── list.cpp
        ├── list.h
        └── main.cpp
```

## Загальне завдання. 

Поширити попередню лабораторну роботу таким чином:

- використання функцій `printf`/`scanf` замінити на використання `cin`/`cout`;
- усі конкатенації рядків замінити на використання `stringstream`;
- замінити метод виводу інформації про об’єкт на метод, що повертає рядок-інформацію про об’єкт, який далі можна виводити на екран;

```cpp
 std::string& Phone::toString(); 
``` 
<!-- TODO: stringstream -->
- замінити метод вводу інформації про об’єкт на метод, що приймає рядок з інформацією про об’єкт, обробляє його та створює об’єкт на базі цієї інформації <!-- TODO: static method; stringstream -->
- поширити клас-список, шляхом реалізації методів роботи з файлами за допомогою файлових потоків (fstream) (якщо використовувалися функції `fprintf`/`fscanf` – замінити їх на класи `ifsteam`/`ofstream`), при цьому сигнатури методів повинні виглядати таким чином:
   - читання (List – клас-список об’єктів, при цьому слід пам’ятати, що при повторному читанні з файлу, попередні дані списку повинні бути очищені):

```cpp
void List::readFromFile(std::string& fileName); 
```
   - запис:  

```cpp
void List::writeToFile(std::string& fileName);
```

<!-- TODO: precise tests -->

## Додаткові обов'язкові умови виконання робот.

- програма має мати документацію, що оформлена за допомогою утиліти doxygen;
- робота повинна бути оформлена згідно "Вимогам до структурної побудови звіту";
- продемонструвати відсутність витоків пам’яті за допомогою утиліти *valgrind*;
- продемонструвати роботу розроблених методів за допомогою модульних тестів;
- у звіті навести ступень покриття коду модульними тестами. 50% - є мінімально допустимим відсотком покриття коду тестами;
- продемонструвати роботу розроблених методів за допомогою модульних тестів;
- не використовувати конструкцію "using namespace std;", замість цього слід робити "using" кожного необхідного класу, наприклад: using std::string,  using std::cout;
- у проекті не повинні використовуватися бібліотеки введення / виведення мови C, а також не повинні використовуватися рядки типу `char*`.

## Контрольні запитання
1.	Як здійснювати виведення даних на екран за допомогою потоків?
2.	Як здійснювати читання даних з клавіатури за допомогою потоків?
3.	Для чого потрібен клас stringstream?
4.	Для чого потрібен клас string? Наведіть аналогію роботи з типом char\*.
5.	Що таке простір імен?
6.	Як здійснювати виведення даних у текстовий файл за допомогою потоків?
7.	Як здійснювати читання даних з файлу за допомогою потоків?
8.	Як здійснювати виведення даних у бінарний файл за допомогою потоків?
9.	Яке призначення маніпуляторів setw(w) та setprecision(d)? Що треба зробити, щоб можна було їх використовувати?
10.	Порівняйте текстові та бінарні файли. Яка у них відмінність?
